// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.4
// source: ember/v1/ember.proto

package emberv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EmberCache_Get_FullMethodName            = "/ember.v1.EmberCache/Get"
	EmberCache_Set_FullMethodName            = "/ember.v1.EmberCache/Set"
	EmberCache_Del_FullMethodName            = "/ember.v1.EmberCache/Del"
	EmberCache_MGet_FullMethodName           = "/ember.v1.EmberCache/MGet"
	EmberCache_MSet_FullMethodName           = "/ember.v1.EmberCache/MSet"
	EmberCache_Incr_FullMethodName           = "/ember.v1.EmberCache/Incr"
	EmberCache_IncrBy_FullMethodName         = "/ember.v1.EmberCache/IncrBy"
	EmberCache_DecrBy_FullMethodName         = "/ember.v1.EmberCache/DecrBy"
	EmberCache_IncrByFloat_FullMethodName    = "/ember.v1.EmberCache/IncrByFloat"
	EmberCache_Append_FullMethodName         = "/ember.v1.EmberCache/Append"
	EmberCache_Strlen_FullMethodName         = "/ember.v1.EmberCache/Strlen"
	EmberCache_Exists_FullMethodName         = "/ember.v1.EmberCache/Exists"
	EmberCache_Expire_FullMethodName         = "/ember.v1.EmberCache/Expire"
	EmberCache_PExpire_FullMethodName        = "/ember.v1.EmberCache/PExpire"
	EmberCache_Persist_FullMethodName        = "/ember.v1.EmberCache/Persist"
	EmberCache_Ttl_FullMethodName            = "/ember.v1.EmberCache/Ttl"
	EmberCache_PTtl_FullMethodName           = "/ember.v1.EmberCache/PTtl"
	EmberCache_Type_FullMethodName           = "/ember.v1.EmberCache/Type"
	EmberCache_Keys_FullMethodName           = "/ember.v1.EmberCache/Keys"
	EmberCache_Rename_FullMethodName         = "/ember.v1.EmberCache/Rename"
	EmberCache_Scan_FullMethodName           = "/ember.v1.EmberCache/Scan"
	EmberCache_LPush_FullMethodName          = "/ember.v1.EmberCache/LPush"
	EmberCache_RPush_FullMethodName          = "/ember.v1.EmberCache/RPush"
	EmberCache_LPop_FullMethodName           = "/ember.v1.EmberCache/LPop"
	EmberCache_RPop_FullMethodName           = "/ember.v1.EmberCache/RPop"
	EmberCache_LRange_FullMethodName         = "/ember.v1.EmberCache/LRange"
	EmberCache_LLen_FullMethodName           = "/ember.v1.EmberCache/LLen"
	EmberCache_HSet_FullMethodName           = "/ember.v1.EmberCache/HSet"
	EmberCache_HGet_FullMethodName           = "/ember.v1.EmberCache/HGet"
	EmberCache_HGetAll_FullMethodName        = "/ember.v1.EmberCache/HGetAll"
	EmberCache_HDel_FullMethodName           = "/ember.v1.EmberCache/HDel"
	EmberCache_HExists_FullMethodName        = "/ember.v1.EmberCache/HExists"
	EmberCache_HLen_FullMethodName           = "/ember.v1.EmberCache/HLen"
	EmberCache_HIncrBy_FullMethodName        = "/ember.v1.EmberCache/HIncrBy"
	EmberCache_HKeys_FullMethodName          = "/ember.v1.EmberCache/HKeys"
	EmberCache_HVals_FullMethodName          = "/ember.v1.EmberCache/HVals"
	EmberCache_HMGet_FullMethodName          = "/ember.v1.EmberCache/HMGet"
	EmberCache_SAdd_FullMethodName           = "/ember.v1.EmberCache/SAdd"
	EmberCache_SRem_FullMethodName           = "/ember.v1.EmberCache/SRem"
	EmberCache_SMembers_FullMethodName       = "/ember.v1.EmberCache/SMembers"
	EmberCache_SIsMember_FullMethodName      = "/ember.v1.EmberCache/SIsMember"
	EmberCache_SCard_FullMethodName          = "/ember.v1.EmberCache/SCard"
	EmberCache_ZAdd_FullMethodName           = "/ember.v1.EmberCache/ZAdd"
	EmberCache_ZRem_FullMethodName           = "/ember.v1.EmberCache/ZRem"
	EmberCache_ZScore_FullMethodName         = "/ember.v1.EmberCache/ZScore"
	EmberCache_ZRank_FullMethodName          = "/ember.v1.EmberCache/ZRank"
	EmberCache_ZCard_FullMethodName          = "/ember.v1.EmberCache/ZCard"
	EmberCache_ZRange_FullMethodName         = "/ember.v1.EmberCache/ZRange"
	EmberCache_VAdd_FullMethodName           = "/ember.v1.EmberCache/VAdd"
	EmberCache_VSim_FullMethodName           = "/ember.v1.EmberCache/VSim"
	EmberCache_VRem_FullMethodName           = "/ember.v1.EmberCache/VRem"
	EmberCache_VGet_FullMethodName           = "/ember.v1.EmberCache/VGet"
	EmberCache_VCard_FullMethodName          = "/ember.v1.EmberCache/VCard"
	EmberCache_VDim_FullMethodName           = "/ember.v1.EmberCache/VDim"
	EmberCache_VInfo_FullMethodName          = "/ember.v1.EmberCache/VInfo"
	EmberCache_Ping_FullMethodName           = "/ember.v1.EmberCache/Ping"
	EmberCache_Echo_FullMethodName           = "/ember.v1.EmberCache/Echo"
	EmberCache_Decr_FullMethodName           = "/ember.v1.EmberCache/Decr"
	EmberCache_Unlink_FullMethodName         = "/ember.v1.EmberCache/Unlink"
	EmberCache_FlushDb_FullMethodName        = "/ember.v1.EmberCache/FlushDb"
	EmberCache_DbSize_FullMethodName         = "/ember.v1.EmberCache/DbSize"
	EmberCache_Info_FullMethodName           = "/ember.v1.EmberCache/Info"
	EmberCache_BgSave_FullMethodName         = "/ember.v1.EmberCache/BgSave"
	EmberCache_BgRewriteAof_FullMethodName   = "/ember.v1.EmberCache/BgRewriteAof"
	EmberCache_SlowLogGet_FullMethodName     = "/ember.v1.EmberCache/SlowLogGet"
	EmberCache_SlowLogLen_FullMethodName     = "/ember.v1.EmberCache/SlowLogLen"
	EmberCache_SlowLogReset_FullMethodName   = "/ember.v1.EmberCache/SlowLogReset"
	EmberCache_Publish_FullMethodName        = "/ember.v1.EmberCache/Publish"
	EmberCache_Subscribe_FullMethodName      = "/ember.v1.EmberCache/Subscribe"
	EmberCache_PubSubChannels_FullMethodName = "/ember.v1.EmberCache/PubSubChannels"
	EmberCache_PubSubNumSub_FullMethodName   = "/ember.v1.EmberCache/PubSubNumSub"
	EmberCache_PubSubNumPat_FullMethodName   = "/ember.v1.EmberCache/PubSubNumPat"
	EmberCache_Pipeline_FullMethodName       = "/ember.v1.EmberCache/Pipeline"
)

// EmberCacheClient is the client API for EmberCache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EmberCache provides a gRPC interface to ember's key-value store.
// all commands route through the same engine as RESP3, so behavior
// is identical regardless of protocol.
type EmberCacheClient interface {
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	Del(ctx context.Context, in *DelRequest, opts ...grpc.CallOption) (*DelResponse, error)
	MGet(ctx context.Context, in *MGetRequest, opts ...grpc.CallOption) (*MGetResponse, error)
	MSet(ctx context.Context, in *MSetRequest, opts ...grpc.CallOption) (*MSetResponse, error)
	Incr(ctx context.Context, in *IncrRequest, opts ...grpc.CallOption) (*IntResponse, error)
	IncrBy(ctx context.Context, in *IncrByRequest, opts ...grpc.CallOption) (*IntResponse, error)
	DecrBy(ctx context.Context, in *DecrByRequest, opts ...grpc.CallOption) (*IntResponse, error)
	IncrByFloat(ctx context.Context, in *IncrByFloatRequest, opts ...grpc.CallOption) (*FloatResponse, error)
	Append(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*IntResponse, error)
	Strlen(ctx context.Context, in *StrlenRequest, opts ...grpc.CallOption) (*IntResponse, error)
	Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*IntResponse, error)
	Expire(ctx context.Context, in *ExpireRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	PExpire(ctx context.Context, in *PExpireRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	Persist(ctx context.Context, in *PersistRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	Ttl(ctx context.Context, in *TtlRequest, opts ...grpc.CallOption) (*TtlResponse, error)
	PTtl(ctx context.Context, in *PTtlRequest, opts ...grpc.CallOption) (*TtlResponse, error)
	Type(ctx context.Context, in *TypeRequest, opts ...grpc.CallOption) (*TypeResponse, error)
	Keys(ctx context.Context, in *KeysRequest, opts ...grpc.CallOption) (*KeysResponse, error)
	Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (*ScanResponse, error)
	LPush(ctx context.Context, in *LPushRequest, opts ...grpc.CallOption) (*IntResponse, error)
	RPush(ctx context.Context, in *RPushRequest, opts ...grpc.CallOption) (*IntResponse, error)
	LPop(ctx context.Context, in *LPopRequest, opts ...grpc.CallOption) (*GetResponse, error)
	RPop(ctx context.Context, in *RPopRequest, opts ...grpc.CallOption) (*GetResponse, error)
	LRange(ctx context.Context, in *LRangeRequest, opts ...grpc.CallOption) (*ArrayResponse, error)
	LLen(ctx context.Context, in *LLenRequest, opts ...grpc.CallOption) (*IntResponse, error)
	HSet(ctx context.Context, in *HSetRequest, opts ...grpc.CallOption) (*IntResponse, error)
	HGet(ctx context.Context, in *HGetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	HGetAll(ctx context.Context, in *HGetAllRequest, opts ...grpc.CallOption) (*HashResponse, error)
	HDel(ctx context.Context, in *HDelRequest, opts ...grpc.CallOption) (*IntResponse, error)
	HExists(ctx context.Context, in *HExistsRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	HLen(ctx context.Context, in *HLenRequest, opts ...grpc.CallOption) (*IntResponse, error)
	HIncrBy(ctx context.Context, in *HIncrByRequest, opts ...grpc.CallOption) (*IntResponse, error)
	HKeys(ctx context.Context, in *HKeysRequest, opts ...grpc.CallOption) (*KeysResponse, error)
	HVals(ctx context.Context, in *HValsRequest, opts ...grpc.CallOption) (*ArrayResponse, error)
	HMGet(ctx context.Context, in *HMGetRequest, opts ...grpc.CallOption) (*OptionalArrayResponse, error)
	SAdd(ctx context.Context, in *SAddRequest, opts ...grpc.CallOption) (*IntResponse, error)
	SRem(ctx context.Context, in *SRemRequest, opts ...grpc.CallOption) (*IntResponse, error)
	SMembers(ctx context.Context, in *SMembersRequest, opts ...grpc.CallOption) (*KeysResponse, error)
	SIsMember(ctx context.Context, in *SIsMemberRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	SCard(ctx context.Context, in *SCardRequest, opts ...grpc.CallOption) (*IntResponse, error)
	ZAdd(ctx context.Context, in *ZAddRequest, opts ...grpc.CallOption) (*IntResponse, error)
	ZRem(ctx context.Context, in *ZRemRequest, opts ...grpc.CallOption) (*IntResponse, error)
	ZScore(ctx context.Context, in *ZScoreRequest, opts ...grpc.CallOption) (*OptionalFloatResponse, error)
	ZRank(ctx context.Context, in *ZRankRequest, opts ...grpc.CallOption) (*OptionalIntResponse, error)
	ZCard(ctx context.Context, in *ZCardRequest, opts ...grpc.CallOption) (*IntResponse, error)
	ZRange(ctx context.Context, in *ZRangeRequest, opts ...grpc.CallOption) (*ZRangeResponse, error)
	VAdd(ctx context.Context, in *VAddRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	VSim(ctx context.Context, in *VSimRequest, opts ...grpc.CallOption) (*VSimResponse, error)
	VRem(ctx context.Context, in *VRemRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	VGet(ctx context.Context, in *VGetRequest, opts ...grpc.CallOption) (*VGetResponse, error)
	VCard(ctx context.Context, in *VCardRequest, opts ...grpc.CallOption) (*IntResponse, error)
	VDim(ctx context.Context, in *VDimRequest, opts ...grpc.CallOption) (*IntResponse, error)
	VInfo(ctx context.Context, in *VInfoRequest, opts ...grpc.CallOption) (*VInfoResponse, error)
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	Decr(ctx context.Context, in *DecrRequest, opts ...grpc.CallOption) (*IntResponse, error)
	Unlink(ctx context.Context, in *UnlinkRequest, opts ...grpc.CallOption) (*DelResponse, error)
	FlushDb(ctx context.Context, in *FlushDbRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	DbSize(ctx context.Context, in *DbSizeRequest, opts ...grpc.CallOption) (*IntResponse, error)
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	BgSave(ctx context.Context, in *BgSaveRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	BgRewriteAof(ctx context.Context, in *BgRewriteAofRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	SlowLogGet(ctx context.Context, in *SlowLogGetRequest, opts ...grpc.CallOption) (*SlowLogGetResponse, error)
	SlowLogLen(ctx context.Context, in *SlowLogLenRequest, opts ...grpc.CallOption) (*IntResponse, error)
	SlowLogReset(ctx context.Context, in *SlowLogResetRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*IntResponse, error)
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeEvent], error)
	PubSubChannels(ctx context.Context, in *PubSubChannelsRequest, opts ...grpc.CallOption) (*KeysResponse, error)
	PubSubNumSub(ctx context.Context, in *PubSubNumSubRequest, opts ...grpc.CallOption) (*PubSubNumSubResponse, error)
	PubSubNumPat(ctx context.Context, in *PubSubNumPatRequest, opts ...grpc.CallOption) (*IntResponse, error)
	Pipeline(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PipelineRequest, PipelineResponse], error)
}

type emberCacheClient struct {
	cc grpc.ClientConnInterface
}

func NewEmberCacheClient(cc grpc.ClientConnInterface) EmberCacheClient {
	return &emberCacheClient{cc}
}

func (c *emberCacheClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, EmberCache_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, EmberCache_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Del(ctx context.Context, in *DelRequest, opts ...grpc.CallOption) (*DelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DelResponse)
	err := c.cc.Invoke(ctx, EmberCache_Del_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) MGet(ctx context.Context, in *MGetRequest, opts ...grpc.CallOption) (*MGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MGetResponse)
	err := c.cc.Invoke(ctx, EmberCache_MGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) MSet(ctx context.Context, in *MSetRequest, opts ...grpc.CallOption) (*MSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MSetResponse)
	err := c.cc.Invoke(ctx, EmberCache_MSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Incr(ctx context.Context, in *IncrRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_Incr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) IncrBy(ctx context.Context, in *IncrByRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_IncrBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) DecrBy(ctx context.Context, in *DecrByRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_DecrBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) IncrByFloat(ctx context.Context, in *IncrByFloatRequest, opts ...grpc.CallOption) (*FloatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FloatResponse)
	err := c.cc.Invoke(ctx, EmberCache_IncrByFloat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Append(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_Append_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Strlen(ctx context.Context, in *StrlenRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_Strlen_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_Exists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Expire(ctx context.Context, in *ExpireRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EmberCache_Expire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) PExpire(ctx context.Context, in *PExpireRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EmberCache_PExpire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Persist(ctx context.Context, in *PersistRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EmberCache_Persist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Ttl(ctx context.Context, in *TtlRequest, opts ...grpc.CallOption) (*TtlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TtlResponse)
	err := c.cc.Invoke(ctx, EmberCache_Ttl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) PTtl(ctx context.Context, in *PTtlRequest, opts ...grpc.CallOption) (*TtlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TtlResponse)
	err := c.cc.Invoke(ctx, EmberCache_PTtl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Type(ctx context.Context, in *TypeRequest, opts ...grpc.CallOption) (*TypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TypeResponse)
	err := c.cc.Invoke(ctx, EmberCache_Type_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Keys(ctx context.Context, in *KeysRequest, opts ...grpc.CallOption) (*KeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KeysResponse)
	err := c.cc.Invoke(ctx, EmberCache_Keys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EmberCache_Rename_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (*ScanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScanResponse)
	err := c.cc.Invoke(ctx, EmberCache_Scan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) LPush(ctx context.Context, in *LPushRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_LPush_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) RPush(ctx context.Context, in *RPushRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_RPush_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) LPop(ctx context.Context, in *LPopRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, EmberCache_LPop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) RPop(ctx context.Context, in *RPopRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, EmberCache_RPop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) LRange(ctx context.Context, in *LRangeRequest, opts ...grpc.CallOption) (*ArrayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArrayResponse)
	err := c.cc.Invoke(ctx, EmberCache_LRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) LLen(ctx context.Context, in *LLenRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_LLen_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HSet(ctx context.Context, in *HSetRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_HSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HGet(ctx context.Context, in *HGetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, EmberCache_HGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HGetAll(ctx context.Context, in *HGetAllRequest, opts ...grpc.CallOption) (*HashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HashResponse)
	err := c.cc.Invoke(ctx, EmberCache_HGetAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HDel(ctx context.Context, in *HDelRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_HDel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HExists(ctx context.Context, in *HExistsRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EmberCache_HExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HLen(ctx context.Context, in *HLenRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_HLen_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HIncrBy(ctx context.Context, in *HIncrByRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_HIncrBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HKeys(ctx context.Context, in *HKeysRequest, opts ...grpc.CallOption) (*KeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KeysResponse)
	err := c.cc.Invoke(ctx, EmberCache_HKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HVals(ctx context.Context, in *HValsRequest, opts ...grpc.CallOption) (*ArrayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArrayResponse)
	err := c.cc.Invoke(ctx, EmberCache_HVals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) HMGet(ctx context.Context, in *HMGetRequest, opts ...grpc.CallOption) (*OptionalArrayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OptionalArrayResponse)
	err := c.cc.Invoke(ctx, EmberCache_HMGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SAdd(ctx context.Context, in *SAddRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_SAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SRem(ctx context.Context, in *SRemRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_SRem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SMembers(ctx context.Context, in *SMembersRequest, opts ...grpc.CallOption) (*KeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KeysResponse)
	err := c.cc.Invoke(ctx, EmberCache_SMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SIsMember(ctx context.Context, in *SIsMemberRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EmberCache_SIsMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SCard(ctx context.Context, in *SCardRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_SCard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) ZAdd(ctx context.Context, in *ZAddRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_ZAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) ZRem(ctx context.Context, in *ZRemRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_ZRem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) ZScore(ctx context.Context, in *ZScoreRequest, opts ...grpc.CallOption) (*OptionalFloatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OptionalFloatResponse)
	err := c.cc.Invoke(ctx, EmberCache_ZScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) ZRank(ctx context.Context, in *ZRankRequest, opts ...grpc.CallOption) (*OptionalIntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OptionalIntResponse)
	err := c.cc.Invoke(ctx, EmberCache_ZRank_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) ZCard(ctx context.Context, in *ZCardRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_ZCard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) ZRange(ctx context.Context, in *ZRangeRequest, opts ...grpc.CallOption) (*ZRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ZRangeResponse)
	err := c.cc.Invoke(ctx, EmberCache_ZRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) VAdd(ctx context.Context, in *VAddRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EmberCache_VAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) VSim(ctx context.Context, in *VSimRequest, opts ...grpc.CallOption) (*VSimResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VSimResponse)
	err := c.cc.Invoke(ctx, EmberCache_VSim_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) VRem(ctx context.Context, in *VRemRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EmberCache_VRem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) VGet(ctx context.Context, in *VGetRequest, opts ...grpc.CallOption) (*VGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VGetResponse)
	err := c.cc.Invoke(ctx, EmberCache_VGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) VCard(ctx context.Context, in *VCardRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_VCard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) VDim(ctx context.Context, in *VDimRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_VDim_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) VInfo(ctx context.Context, in *VInfoRequest, opts ...grpc.CallOption) (*VInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VInfoResponse)
	err := c.cc.Invoke(ctx, EmberCache_VInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, EmberCache_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EchoResponse)
	err := c.cc.Invoke(ctx, EmberCache_Echo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Decr(ctx context.Context, in *DecrRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_Decr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Unlink(ctx context.Context, in *UnlinkRequest, opts ...grpc.CallOption) (*DelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DelResponse)
	err := c.cc.Invoke(ctx, EmberCache_Unlink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) FlushDb(ctx context.Context, in *FlushDbRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EmberCache_FlushDb_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) DbSize(ctx context.Context, in *DbSizeRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_DbSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, EmberCache_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) BgSave(ctx context.Context, in *BgSaveRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EmberCache_BgSave_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) BgRewriteAof(ctx context.Context, in *BgRewriteAofRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EmberCache_BgRewriteAof_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SlowLogGet(ctx context.Context, in *SlowLogGetRequest, opts ...grpc.CallOption) (*SlowLogGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SlowLogGetResponse)
	err := c.cc.Invoke(ctx, EmberCache_SlowLogGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SlowLogLen(ctx context.Context, in *SlowLogLenRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_SlowLogLen_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) SlowLogReset(ctx context.Context, in *SlowLogResetRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EmberCache_SlowLogReset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EmberCache_ServiceDesc.Streams[0], EmberCache_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, SubscribeEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EmberCache_SubscribeClient = grpc.ServerStreamingClient[SubscribeEvent]

func (c *emberCacheClient) PubSubChannels(ctx context.Context, in *PubSubChannelsRequest, opts ...grpc.CallOption) (*KeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KeysResponse)
	err := c.cc.Invoke(ctx, EmberCache_PubSubChannels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) PubSubNumSub(ctx context.Context, in *PubSubNumSubRequest, opts ...grpc.CallOption) (*PubSubNumSubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PubSubNumSubResponse)
	err := c.cc.Invoke(ctx, EmberCache_PubSubNumSub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) PubSubNumPat(ctx context.Context, in *PubSubNumPatRequest, opts ...grpc.CallOption) (*IntResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntResponse)
	err := c.cc.Invoke(ctx, EmberCache_PubSubNumPat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emberCacheClient) Pipeline(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PipelineRequest, PipelineResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EmberCache_ServiceDesc.Streams[1], EmberCache_Pipeline_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PipelineRequest, PipelineResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EmberCache_PipelineClient = grpc.BidiStreamingClient[PipelineRequest, PipelineResponse]

// EmberCacheServer is the server API for EmberCache service.
// All implementations must embed UnimplementedEmberCacheServer
// for forward compatibility.
//
// EmberCache provides a gRPC interface to ember's key-value store.
// all commands route through the same engine as RESP3, so behavior
// is identical regardless of protocol.
type EmberCacheServer interface {
	Get(context.Context, *GetRequest) (*GetResponse, error)
	Set(context.Context, *SetRequest) (*SetResponse, error)
	Del(context.Context, *DelRequest) (*DelResponse, error)
	MGet(context.Context, *MGetRequest) (*MGetResponse, error)
	MSet(context.Context, *MSetRequest) (*MSetResponse, error)
	Incr(context.Context, *IncrRequest) (*IntResponse, error)
	IncrBy(context.Context, *IncrByRequest) (*IntResponse, error)
	DecrBy(context.Context, *DecrByRequest) (*IntResponse, error)
	IncrByFloat(context.Context, *IncrByFloatRequest) (*FloatResponse, error)
	Append(context.Context, *AppendRequest) (*IntResponse, error)
	Strlen(context.Context, *StrlenRequest) (*IntResponse, error)
	Exists(context.Context, *ExistsRequest) (*IntResponse, error)
	Expire(context.Context, *ExpireRequest) (*BoolResponse, error)
	PExpire(context.Context, *PExpireRequest) (*BoolResponse, error)
	Persist(context.Context, *PersistRequest) (*BoolResponse, error)
	Ttl(context.Context, *TtlRequest) (*TtlResponse, error)
	PTtl(context.Context, *PTtlRequest) (*TtlResponse, error)
	Type(context.Context, *TypeRequest) (*TypeResponse, error)
	Keys(context.Context, *KeysRequest) (*KeysResponse, error)
	Rename(context.Context, *RenameRequest) (*StatusResponse, error)
	Scan(context.Context, *ScanRequest) (*ScanResponse, error)
	LPush(context.Context, *LPushRequest) (*IntResponse, error)
	RPush(context.Context, *RPushRequest) (*IntResponse, error)
	LPop(context.Context, *LPopRequest) (*GetResponse, error)
	RPop(context.Context, *RPopRequest) (*GetResponse, error)
	LRange(context.Context, *LRangeRequest) (*ArrayResponse, error)
	LLen(context.Context, *LLenRequest) (*IntResponse, error)
	HSet(context.Context, *HSetRequest) (*IntResponse, error)
	HGet(context.Context, *HGetRequest) (*GetResponse, error)
	HGetAll(context.Context, *HGetAllRequest) (*HashResponse, error)
	HDel(context.Context, *HDelRequest) (*IntResponse, error)
	HExists(context.Context, *HExistsRequest) (*BoolResponse, error)
	HLen(context.Context, *HLenRequest) (*IntResponse, error)
	HIncrBy(context.Context, *HIncrByRequest) (*IntResponse, error)
	HKeys(context.Context, *HKeysRequest) (*KeysResponse, error)
	HVals(context.Context, *HValsRequest) (*ArrayResponse, error)
	HMGet(context.Context, *HMGetRequest) (*OptionalArrayResponse, error)
	SAdd(context.Context, *SAddRequest) (*IntResponse, error)
	SRem(context.Context, *SRemRequest) (*IntResponse, error)
	SMembers(context.Context, *SMembersRequest) (*KeysResponse, error)
	SIsMember(context.Context, *SIsMemberRequest) (*BoolResponse, error)
	SCard(context.Context, *SCardRequest) (*IntResponse, error)
	ZAdd(context.Context, *ZAddRequest) (*IntResponse, error)
	ZRem(context.Context, *ZRemRequest) (*IntResponse, error)
	ZScore(context.Context, *ZScoreRequest) (*OptionalFloatResponse, error)
	ZRank(context.Context, *ZRankRequest) (*OptionalIntResponse, error)
	ZCard(context.Context, *ZCardRequest) (*IntResponse, error)
	ZRange(context.Context, *ZRangeRequest) (*ZRangeResponse, error)
	VAdd(context.Context, *VAddRequest) (*BoolResponse, error)
	VSim(context.Context, *VSimRequest) (*VSimResponse, error)
	VRem(context.Context, *VRemRequest) (*BoolResponse, error)
	VGet(context.Context, *VGetRequest) (*VGetResponse, error)
	VCard(context.Context, *VCardRequest) (*IntResponse, error)
	VDim(context.Context, *VDimRequest) (*IntResponse, error)
	VInfo(context.Context, *VInfoRequest) (*VInfoResponse, error)
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)
	Decr(context.Context, *DecrRequest) (*IntResponse, error)
	Unlink(context.Context, *UnlinkRequest) (*DelResponse, error)
	FlushDb(context.Context, *FlushDbRequest) (*StatusResponse, error)
	DbSize(context.Context, *DbSizeRequest) (*IntResponse, error)
	Info(context.Context, *InfoRequest) (*InfoResponse, error)
	BgSave(context.Context, *BgSaveRequest) (*StatusResponse, error)
	BgRewriteAof(context.Context, *BgRewriteAofRequest) (*StatusResponse, error)
	SlowLogGet(context.Context, *SlowLogGetRequest) (*SlowLogGetResponse, error)
	SlowLogLen(context.Context, *SlowLogLenRequest) (*IntResponse, error)
	SlowLogReset(context.Context, *SlowLogResetRequest) (*StatusResponse, error)
	Publish(context.Context, *PublishRequest) (*IntResponse, error)
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[SubscribeEvent]) error
	PubSubChannels(context.Context, *PubSubChannelsRequest) (*KeysResponse, error)
	PubSubNumSub(context.Context, *PubSubNumSubRequest) (*PubSubNumSubResponse, error)
	PubSubNumPat(context.Context, *PubSubNumPatRequest) (*IntResponse, error)
	Pipeline(grpc.BidiStreamingServer[PipelineRequest, PipelineResponse]) error
	mustEmbedUnimplementedEmberCacheServer()
}

// UnimplementedEmberCacheServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEmberCacheServer struct{}

func (UnimplementedEmberCacheServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedEmberCacheServer) Set(context.Context, *SetRequest) (*SetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedEmberCacheServer) Del(context.Context, *DelRequest) (*DelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Del not implemented")
}
func (UnimplementedEmberCacheServer) MGet(context.Context, *MGetRequest) (*MGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MGet not implemented")
}
func (UnimplementedEmberCacheServer) MSet(context.Context, *MSetRequest) (*MSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MSet not implemented")
}
func (UnimplementedEmberCacheServer) Incr(context.Context, *IncrRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Incr not implemented")
}
func (UnimplementedEmberCacheServer) IncrBy(context.Context, *IncrByRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IncrBy not implemented")
}
func (UnimplementedEmberCacheServer) DecrBy(context.Context, *DecrByRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DecrBy not implemented")
}
func (UnimplementedEmberCacheServer) IncrByFloat(context.Context, *IncrByFloatRequest) (*FloatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IncrByFloat not implemented")
}
func (UnimplementedEmberCacheServer) Append(context.Context, *AppendRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Append not implemented")
}
func (UnimplementedEmberCacheServer) Strlen(context.Context, *StrlenRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Strlen not implemented")
}
func (UnimplementedEmberCacheServer) Exists(context.Context, *ExistsRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedEmberCacheServer) Expire(context.Context, *ExpireRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Expire not implemented")
}
func (UnimplementedEmberCacheServer) PExpire(context.Context, *PExpireRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PExpire not implemented")
}
func (UnimplementedEmberCacheServer) Persist(context.Context, *PersistRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Persist not implemented")
}
func (UnimplementedEmberCacheServer) Ttl(context.Context, *TtlRequest) (*TtlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ttl not implemented")
}
func (UnimplementedEmberCacheServer) PTtl(context.Context, *PTtlRequest) (*TtlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PTtl not implemented")
}
func (UnimplementedEmberCacheServer) Type(context.Context, *TypeRequest) (*TypeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Type not implemented")
}
func (UnimplementedEmberCacheServer) Keys(context.Context, *KeysRequest) (*KeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Keys not implemented")
}
func (UnimplementedEmberCacheServer) Rename(context.Context, *RenameRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Rename not implemented")
}
func (UnimplementedEmberCacheServer) Scan(context.Context, *ScanRequest) (*ScanResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedEmberCacheServer) LPush(context.Context, *LPushRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LPush not implemented")
}
func (UnimplementedEmberCacheServer) RPush(context.Context, *RPushRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RPush not implemented")
}
func (UnimplementedEmberCacheServer) LPop(context.Context, *LPopRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LPop not implemented")
}
func (UnimplementedEmberCacheServer) RPop(context.Context, *RPopRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RPop not implemented")
}
func (UnimplementedEmberCacheServer) LRange(context.Context, *LRangeRequest) (*ArrayResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LRange not implemented")
}
func (UnimplementedEmberCacheServer) LLen(context.Context, *LLenRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LLen not implemented")
}
func (UnimplementedEmberCacheServer) HSet(context.Context, *HSetRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HSet not implemented")
}
func (UnimplementedEmberCacheServer) HGet(context.Context, *HGetRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HGet not implemented")
}
func (UnimplementedEmberCacheServer) HGetAll(context.Context, *HGetAllRequest) (*HashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HGetAll not implemented")
}
func (UnimplementedEmberCacheServer) HDel(context.Context, *HDelRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HDel not implemented")
}
func (UnimplementedEmberCacheServer) HExists(context.Context, *HExistsRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HExists not implemented")
}
func (UnimplementedEmberCacheServer) HLen(context.Context, *HLenRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HLen not implemented")
}
func (UnimplementedEmberCacheServer) HIncrBy(context.Context, *HIncrByRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HIncrBy not implemented")
}
func (UnimplementedEmberCacheServer) HKeys(context.Context, *HKeysRequest) (*KeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HKeys not implemented")
}
func (UnimplementedEmberCacheServer) HVals(context.Context, *HValsRequest) (*ArrayResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HVals not implemented")
}
func (UnimplementedEmberCacheServer) HMGet(context.Context, *HMGetRequest) (*OptionalArrayResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HMGet not implemented")
}
func (UnimplementedEmberCacheServer) SAdd(context.Context, *SAddRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SAdd not implemented")
}
func (UnimplementedEmberCacheServer) SRem(context.Context, *SRemRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SRem not implemented")
}
func (UnimplementedEmberCacheServer) SMembers(context.Context, *SMembersRequest) (*KeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SMembers not implemented")
}
func (UnimplementedEmberCacheServer) SIsMember(context.Context, *SIsMemberRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SIsMember not implemented")
}
func (UnimplementedEmberCacheServer) SCard(context.Context, *SCardRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SCard not implemented")
}
func (UnimplementedEmberCacheServer) ZAdd(context.Context, *ZAddRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZAdd not implemented")
}
func (UnimplementedEmberCacheServer) ZRem(context.Context, *ZRemRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZRem not implemented")
}
func (UnimplementedEmberCacheServer) ZScore(context.Context, *ZScoreRequest) (*OptionalFloatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZScore not implemented")
}
func (UnimplementedEmberCacheServer) ZRank(context.Context, *ZRankRequest) (*OptionalIntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZRank not implemented")
}
func (UnimplementedEmberCacheServer) ZCard(context.Context, *ZCardRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZCard not implemented")
}
func (UnimplementedEmberCacheServer) ZRange(context.Context, *ZRangeRequest) (*ZRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZRange not implemented")
}
func (UnimplementedEmberCacheServer) VAdd(context.Context, *VAddRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VAdd not implemented")
}
func (UnimplementedEmberCacheServer) VSim(context.Context, *VSimRequest) (*VSimResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VSim not implemented")
}
func (UnimplementedEmberCacheServer) VRem(context.Context, *VRemRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VRem not implemented")
}
func (UnimplementedEmberCacheServer) VGet(context.Context, *VGetRequest) (*VGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VGet not implemented")
}
func (UnimplementedEmberCacheServer) VCard(context.Context, *VCardRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VCard not implemented")
}
func (UnimplementedEmberCacheServer) VDim(context.Context, *VDimRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VDim not implemented")
}
func (UnimplementedEmberCacheServer) VInfo(context.Context, *VInfoRequest) (*VInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VInfo not implemented")
}
func (UnimplementedEmberCacheServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedEmberCacheServer) Echo(context.Context, *EchoRequest) (*EchoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Echo not implemented")
}
func (UnimplementedEmberCacheServer) Decr(context.Context, *DecrRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Decr not implemented")
}
func (UnimplementedEmberCacheServer) Unlink(context.Context, *UnlinkRequest) (*DelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Unlink not implemented")
}
func (UnimplementedEmberCacheServer) FlushDb(context.Context, *FlushDbRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FlushDb not implemented")
}
func (UnimplementedEmberCacheServer) DbSize(context.Context, *DbSizeRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DbSize not implemented")
}
func (UnimplementedEmberCacheServer) Info(context.Context, *InfoRequest) (*InfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedEmberCacheServer) BgSave(context.Context, *BgSaveRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BgSave not implemented")
}
func (UnimplementedEmberCacheServer) BgRewriteAof(context.Context, *BgRewriteAofRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BgRewriteAof not implemented")
}
func (UnimplementedEmberCacheServer) SlowLogGet(context.Context, *SlowLogGetRequest) (*SlowLogGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SlowLogGet not implemented")
}
func (UnimplementedEmberCacheServer) SlowLogLen(context.Context, *SlowLogLenRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SlowLogLen not implemented")
}
func (UnimplementedEmberCacheServer) SlowLogReset(context.Context, *SlowLogResetRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SlowLogReset not implemented")
}
func (UnimplementedEmberCacheServer) Publish(context.Context, *PublishRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedEmberCacheServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[SubscribeEvent]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedEmberCacheServer) PubSubChannels(context.Context, *PubSubChannelsRequest) (*KeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PubSubChannels not implemented")
}
func (UnimplementedEmberCacheServer) PubSubNumSub(context.Context, *PubSubNumSubRequest) (*PubSubNumSubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PubSubNumSub not implemented")
}
func (UnimplementedEmberCacheServer) PubSubNumPat(context.Context, *PubSubNumPatRequest) (*IntResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PubSubNumPat not implemented")
}
func (UnimplementedEmberCacheServer) Pipeline(grpc.BidiStreamingServer[PipelineRequest, PipelineResponse]) error {
	return status.Error(codes.Unimplemented, "method Pipeline not implemented")
}
func (UnimplementedEmberCacheServer) mustEmbedUnimplementedEmberCacheServer() {}
func (UnimplementedEmberCacheServer) testEmbeddedByValue()                    {}

// UnsafeEmberCacheServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmberCacheServer will
// result in compilation errors.
type UnsafeEmberCacheServer interface {
	mustEmbedUnimplementedEmberCacheServer()
}

func RegisterEmberCacheServer(s grpc.ServiceRegistrar, srv EmberCacheServer) {
	// If the following call panics, it indicates UnimplementedEmberCacheServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EmberCache_ServiceDesc, srv)
}

func _EmberCache_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Del_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Del(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Del_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Del(ctx, req.(*DelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_MGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).MGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_MGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).MGet(ctx, req.(*MGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_MSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).MSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_MSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).MSet(ctx, req.(*MSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Incr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Incr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Incr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Incr(ctx, req.(*IncrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_IncrBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).IncrBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_IncrBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).IncrBy(ctx, req.(*IncrByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_DecrBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecrByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).DecrBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_DecrBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).DecrBy(ctx, req.(*DecrByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_IncrByFloat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrByFloatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).IncrByFloat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_IncrByFloat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).IncrByFloat(ctx, req.(*IncrByFloatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Append_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Append(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Append_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Append(ctx, req.(*AppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Strlen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StrlenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Strlen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Strlen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Strlen(ctx, req.(*StrlenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Exists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Exists(ctx, req.(*ExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Expire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Expire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Expire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Expire(ctx, req.(*ExpireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_PExpire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PExpireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).PExpire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_PExpire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).PExpire(ctx, req.(*PExpireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Persist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PersistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Persist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Persist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Persist(ctx, req.(*PersistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Ttl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TtlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Ttl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Ttl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Ttl(ctx, req.(*TtlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_PTtl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PTtlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).PTtl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_PTtl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).PTtl(ctx, req.(*PTtlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Type_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Type(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Type_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Type(ctx, req.(*TypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Keys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Keys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Keys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Keys(ctx, req.(*KeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Rename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Rename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Rename_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Rename(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Scan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Scan(ctx, req.(*ScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_LPush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LPushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).LPush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_LPush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).LPush(ctx, req.(*LPushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_RPush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).RPush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_RPush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).RPush(ctx, req.(*RPushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_LPop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LPopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).LPop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_LPop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).LPop(ctx, req.(*LPopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_RPop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).RPop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_RPop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).RPop(ctx, req.(*RPopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_LRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).LRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_LRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).LRange(ctx, req.(*LRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_LLen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LLenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).LLen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_LLen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).LLen(ctx, req.(*LLenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HSet(ctx, req.(*HSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HGet(ctx, req.(*HGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HGetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HGetAllRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HGetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HGetAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HGetAll(ctx, req.(*HGetAllRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HDel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HDel(ctx, req.(*HDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HExists(ctx, req.(*HExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HLen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HLenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HLen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HLen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HLen(ctx, req.(*HLenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HIncrBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HIncrByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HIncrBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HIncrBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HIncrBy(ctx, req.(*HIncrByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HKeys(ctx, req.(*HKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HVals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HValsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HVals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HVals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HVals(ctx, req.(*HValsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_HMGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HMGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).HMGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_HMGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).HMGet(ctx, req.(*HMGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SAdd(ctx, req.(*SAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SRem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SRemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SRem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SRem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SRem(ctx, req.(*SRemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SMembers(ctx, req.(*SMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SIsMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SIsMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SIsMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SIsMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SIsMember(ctx, req.(*SIsMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SCard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SCard(ctx, req.(*SCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_ZAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).ZAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_ZAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).ZAdd(ctx, req.(*ZAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_ZRem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZRemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).ZRem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_ZRem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).ZRem(ctx, req.(*ZRemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_ZScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).ZScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_ZScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).ZScore(ctx, req.(*ZScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_ZRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZRankRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).ZRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_ZRank_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).ZRank(ctx, req.(*ZRankRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_ZCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).ZCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_ZCard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).ZCard(ctx, req.(*ZCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_ZRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).ZRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_ZRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).ZRange(ctx, req.(*ZRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_VAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).VAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_VAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).VAdd(ctx, req.(*VAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_VSim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VSimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).VSim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_VSim_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).VSim(ctx, req.(*VSimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_VRem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VRemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).VRem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_VRem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).VRem(ctx, req.(*VRemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_VGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).VGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_VGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).VGet(ctx, req.(*VGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_VCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).VCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_VCard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).VCard(ctx, req.(*VCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_VDim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VDimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).VDim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_VDim_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).VDim(ctx, req.(*VDimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_VInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).VInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_VInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).VInfo(ctx, req.(*VInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Echo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Decr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Decr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Decr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Decr(ctx, req.(*DecrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Unlink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Unlink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Unlink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Unlink(ctx, req.(*UnlinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_FlushDb_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushDbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).FlushDb(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_FlushDb_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).FlushDb(ctx, req.(*FlushDbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_DbSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DbSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).DbSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_DbSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).DbSize(ctx, req.(*DbSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_BgSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgSaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).BgSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_BgSave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).BgSave(ctx, req.(*BgSaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_BgRewriteAof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgRewriteAofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).BgRewriteAof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_BgRewriteAof_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).BgRewriteAof(ctx, req.(*BgRewriteAofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SlowLogGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlowLogGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SlowLogGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SlowLogGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SlowLogGet(ctx, req.(*SlowLogGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SlowLogLen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlowLogLenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SlowLogLen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SlowLogLen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SlowLogLen(ctx, req.(*SlowLogLenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_SlowLogReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlowLogResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).SlowLogReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_SlowLogReset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).SlowLogReset(ctx, req.(*SlowLogResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmberCacheServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, SubscribeEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EmberCache_SubscribeServer = grpc.ServerStreamingServer[SubscribeEvent]

func _EmberCache_PubSubChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PubSubChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).PubSubChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_PubSubChannels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).PubSubChannels(ctx, req.(*PubSubChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_PubSubNumSub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PubSubNumSubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).PubSubNumSub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_PubSubNumSub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).PubSubNumSub(ctx, req.(*PubSubNumSubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_PubSubNumPat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PubSubNumPatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmberCacheServer).PubSubNumPat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmberCache_PubSubNumPat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmberCacheServer).PubSubNumPat(ctx, req.(*PubSubNumPatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmberCache_Pipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EmberCacheServer).Pipeline(&grpc.GenericServerStream[PipelineRequest, PipelineResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EmberCache_PipelineServer = grpc.BidiStreamingServer[PipelineRequest, PipelineResponse]

// EmberCache_ServiceDesc is the grpc.ServiceDesc for EmberCache service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmberCache_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ember.v1.EmberCache",
	HandlerType: (*EmberCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _EmberCache_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _EmberCache_Set_Handler,
		},
		{
			MethodName: "Del",
			Handler:    _EmberCache_Del_Handler,
		},
		{
			MethodName: "MGet",
			Handler:    _EmberCache_MGet_Handler,
		},
		{
			MethodName: "MSet",
			Handler:    _EmberCache_MSet_Handler,
		},
		{
			MethodName: "Incr",
			Handler:    _EmberCache_Incr_Handler,
		},
		{
			MethodName: "IncrBy",
			Handler:    _EmberCache_IncrBy_Handler,
		},
		{
			MethodName: "DecrBy",
			Handler:    _EmberCache_DecrBy_Handler,
		},
		{
			MethodName: "IncrByFloat",
			Handler:    _EmberCache_IncrByFloat_Handler,
		},
		{
			MethodName: "Append",
			Handler:    _EmberCache_Append_Handler,
		},
		{
			MethodName: "Strlen",
			Handler:    _EmberCache_Strlen_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _EmberCache_Exists_Handler,
		},
		{
			MethodName: "Expire",
			Handler:    _EmberCache_Expire_Handler,
		},
		{
			MethodName: "PExpire",
			Handler:    _EmberCache_PExpire_Handler,
		},
		{
			MethodName: "Persist",
			Handler:    _EmberCache_Persist_Handler,
		},
		{
			MethodName: "Ttl",
			Handler:    _EmberCache_Ttl_Handler,
		},
		{
			MethodName: "PTtl",
			Handler:    _EmberCache_PTtl_Handler,
		},
		{
			MethodName: "Type",
			Handler:    _EmberCache_Type_Handler,
		},
		{
			MethodName: "Keys",
			Handler:    _EmberCache_Keys_Handler,
		},
		{
			MethodName: "Rename",
			Handler:    _EmberCache_Rename_Handler,
		},
		{
			MethodName: "Scan",
			Handler:    _EmberCache_Scan_Handler,
		},
		{
			MethodName: "LPush",
			Handler:    _EmberCache_LPush_Handler,
		},
		{
			MethodName: "RPush",
			Handler:    _EmberCache_RPush_Handler,
		},
		{
			MethodName: "LPop",
			Handler:    _EmberCache_LPop_Handler,
		},
		{
			MethodName: "RPop",
			Handler:    _EmberCache_RPop_Handler,
		},
		{
			MethodName: "LRange",
			Handler:    _EmberCache_LRange_Handler,
		},
		{
			MethodName: "LLen",
			Handler:    _EmberCache_LLen_Handler,
		},
		{
			MethodName: "HSet",
			Handler:    _EmberCache_HSet_Handler,
		},
		{
			MethodName: "HGet",
			Handler:    _EmberCache_HGet_Handler,
		},
		{
			MethodName: "HGetAll",
			Handler:    _EmberCache_HGetAll_Handler,
		},
		{
			MethodName: "HDel",
			Handler:    _EmberCache_HDel_Handler,
		},
		{
			MethodName: "HExists",
			Handler:    _EmberCache_HExists_Handler,
		},
		{
			MethodName: "HLen",
			Handler:    _EmberCache_HLen_Handler,
		},
		{
			MethodName: "HIncrBy",
			Handler:    _EmberCache_HIncrBy_Handler,
		},
		{
			MethodName: "HKeys",
			Handler:    _EmberCache_HKeys_Handler,
		},
		{
			MethodName: "HVals",
			Handler:    _EmberCache_HVals_Handler,
		},
		{
			MethodName: "HMGet",
			Handler:    _EmberCache_HMGet_Handler,
		},
		{
			MethodName: "SAdd",
			Handler:    _EmberCache_SAdd_Handler,
		},
		{
			MethodName: "SRem",
			Handler:    _EmberCache_SRem_Handler,
		},
		{
			MethodName: "SMembers",
			Handler:    _EmberCache_SMembers_Handler,
		},
		{
			MethodName: "SIsMember",
			Handler:    _EmberCache_SIsMember_Handler,
		},
		{
			MethodName: "SCard",
			Handler:    _EmberCache_SCard_Handler,
		},
		{
			MethodName: "ZAdd",
			Handler:    _EmberCache_ZAdd_Handler,
		},
		{
			MethodName: "ZRem",
			Handler:    _EmberCache_ZRem_Handler,
		},
		{
			MethodName: "ZScore",
			Handler:    _EmberCache_ZScore_Handler,
		},
		{
			MethodName: "ZRank",
			Handler:    _EmberCache_ZRank_Handler,
		},
		{
			MethodName: "ZCard",
			Handler:    _EmberCache_ZCard_Handler,
		},
		{
			MethodName: "ZRange",
			Handler:    _EmberCache_ZRange_Handler,
		},
		{
			MethodName: "VAdd",
			Handler:    _EmberCache_VAdd_Handler,
		},
		{
			MethodName: "VSim",
			Handler:    _EmberCache_VSim_Handler,
		},
		{
			MethodName: "VRem",
			Handler:    _EmberCache_VRem_Handler,
		},
		{
			MethodName: "VGet",
			Handler:    _EmberCache_VGet_Handler,
		},
		{
			MethodName: "VCard",
			Handler:    _EmberCache_VCard_Handler,
		},
		{
			MethodName: "VDim",
			Handler:    _EmberCache_VDim_Handler,
		},
		{
			MethodName: "VInfo",
			Handler:    _EmberCache_VInfo_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _EmberCache_Ping_Handler,
		},
		{
			MethodName: "Echo",
			Handler:    _EmberCache_Echo_Handler,
		},
		{
			MethodName: "Decr",
			Handler:    _EmberCache_Decr_Handler,
		},
		{
			MethodName: "Unlink",
			Handler:    _EmberCache_Unlink_Handler,
		},
		{
			MethodName: "FlushDb",
			Handler:    _EmberCache_FlushDb_Handler,
		},
		{
			MethodName: "DbSize",
			Handler:    _EmberCache_DbSize_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _EmberCache_Info_Handler,
		},
		{
			MethodName: "BgSave",
			Handler:    _EmberCache_BgSave_Handler,
		},
		{
			MethodName: "BgRewriteAof",
			Handler:    _EmberCache_BgRewriteAof_Handler,
		},
		{
			MethodName: "SlowLogGet",
			Handler:    _EmberCache_SlowLogGet_Handler,
		},
		{
			MethodName: "SlowLogLen",
			Handler:    _EmberCache_SlowLogLen_Handler,
		},
		{
			MethodName: "SlowLogReset",
			Handler:    _EmberCache_SlowLogReset_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _EmberCache_Publish_Handler,
		},
		{
			MethodName: "PubSubChannels",
			Handler:    _EmberCache_PubSubChannels_Handler,
		},
		{
			MethodName: "PubSubNumSub",
			Handler:    _EmberCache_PubSubNumSub_Handler,
		},
		{
			MethodName: "PubSubNumPat",
			Handler:    _EmberCache_PubSubNumPat_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _EmberCache_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Pipeline",
			Handler:       _EmberCache_Pipeline_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "ember/v1/ember.proto",
}
